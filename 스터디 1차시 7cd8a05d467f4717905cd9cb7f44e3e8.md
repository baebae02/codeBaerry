# 스터디 1차시

Date: 2022년 7월 11일

스터디 1차시

‼️ 주제 : 스택  & 큐 

‼️ 발표자 : 배서현

‼️ 추가 논의 사항 : 깃허브 사용법 & 과제 

### 과제

 [스택](https://www.acmicpc.net/problem/10828),  [균형잡힌 세상](https://www.acmicpc.net/problem/4949),  [스택 수열](https://www.acmicpc.net/problem/1874),  [프린터 큐](https://www.acmicpc.net/problem/1966),  [회전하는 큐](https://www.acmicpc.net/problem/1021)

### 스택(stack)

- 목록의 끝에서만 접근할 수 있는 자료구조이자 선형 구조 LIFO(Last In First Out)이다 .
- 한국말로는 후입선출, 나중에 넣은 것이 먼저 나온다는 뜻.
- 스택의 구현은 **리스트(혹은 연결리스트)**로 하면 된다.

```python
c언어
int Stack[10];

Python
s = []
```

### 스택 함수

```python
S.top(): 스택의 가장 윗 데이터를 반환한다. 만약 스택이 비었다면 이 연산은 정의불가 상태이다.
S.pop(): 스택의 가장 윗 데이터를 삭제하고 반환한다. 스택이 비었다면 연산 정의불가 상태.
S.push(x): 스택의 가장 윗 데이터 자리 위에 메모리를 생성, 데이터 x를 넣는다.
S.empty(): 스택이 비어있다면 1, 아니면 0을 반환한다.
```

<aside>
💡 Python 내장 모듈에는 Stack이 따로 존재하지 않아서, 보통 Deque 라이브러리를 사용한다!

</aside>

‼️ 근데 pop은 기본적으로 내장되어 있음.

### Deque 라이브러리

```python
from collections import deque

dq=deque() # 덱 생성
dq.append() # 덱의 가장 오른쪽에 원소 삽입
dq.popleft() # 가장 왼쪽 원소 반환
dq.appendleft() # 덱의 가장 왼쪽에 원소 삽입
dp.pop() # 가장 오른쪽 원소 반환
dp.clear() # 모든 원소 제거
dp.copy() # 덱 복사
dp.count(x) #x와 같은 원소의 개수를 계산
'''공식문서 : https://docs.python.org/3.8/library/collections.html#collections.deque'''
```

### S.pop()

가장 윗 데이터를 삭제, 반환하는 함수

- 이지만 사실 s.pop(-1)이라고 생각하면 된다.
- 리스트로 구현할거니까 가장 **오른쪽 요소**를 삭제하는 함수가 되겠다.
- s.pop(1), s.pop(0) 처럼 **index**를 설정하여 요소를 뺄 수도 있다.

~~(그럴거면 LIFO가 아니지않나! 하지만 편리성을 위해 그런 것 같다. )~~

- s.pop, 즉 ‘팝' 하는 요소를 프린트 할 수도 있다 !
- 만약 크기에 벗어나는 요소를 pop 하려고 나면 index 에러가 난다! (index out of range)

```python
s = [1, 2, 3, 4, 5]
print(s) #[1, 2, 3, 4, 5]

s.pop() #s.pop() == s.pop(-1)
print(s) #[1, 2, 3, 4]

s.pop(2)
print(s) #[1, 2, 4]

print(s.pop(1)) #2
print(s) #[1, 4]

```

### S.top()

가장 윗 데이터를 반환하는 함수

- 어디선 peek이라고 함.
- 근데 top도, peek도 라이브러리에 등록되어있지 않음. [-1]을 하면 되기 때문 …

### S.push()

가장 윗 데이터 자리 위에 데이터를 추가하는 함수

- list로 구현한다면 append와 같다고 생각하면 됨.

```python
s_list = [1, 4]
print(s_list.append(1)) # None
print(s_list) # [1, 4, 1]

print(s_list.append(2)) # None
print(s_list) # [1, 4, 1, 2]
```

### S.empty()

스택이 비어있다면 1, 아니면 0을 반환하는 함수

- 마찬가지로 list에 empty라는 속성은 없다 !
- 대신 len() == 0 으로 리스트가 비었는지 확인할 수 있다.

```python
print(len(s_list) == 0) # False
```

### Stack 구현

```python
class Stack:
    #리스트를 이용하여 스택 생성
    def __init__(self, limit: int= 100):
        self.top = []
        self.limit = limit
    #스택 크기 반환
    def __len__(self) -> bool :
        return len(self.top)
    #스택 내부 자료 전체를 string으로 변환하여 반환
    def __str__(self) -> str :
        return str(self.top[::1])

    #구현함수
    #스택에 원소 삽입
    def push(self, item):
        if(len(self.pop)>=self.limit):
            self.top.append(item)
    #스택 가장 위에 있는 원소를 삭제하고 반환
    def pop(self):
        if not self.isEmpty():
            return self.top.pop(-1)
        else:
            print("Stack underflow")
            exit()
    #스택 가장 위에 있는 원소를 반환
    def peek(self):
        if not self.isEmpty():
            return self.top[-1]
        else:
            print("underflow")
            exit()
    #스택을 비움
    def clear(self):
        self.top=[]
    #스택 안에 특정 item이 포함되어 있는지를 bool값으로 반환
    def isContain(self, item) -> bool:
        return item in self.top
    #스택이 비어있는 지를 bool값으로 반환
    def isEmpty(self) -> bool :
        return len(self.top)==0
    #스택이 가득 차 있는 지를 bool값으로 반환
    def isFull(self) -> bool :
        return self.size()==self.limit
    #스택의 크기를 int 값으로 반환 
    def size(self) -> int :
        return len(self.top) 
```

---

### 큐(queue)

- 목록의 앞에서만 접근할 수 있는 자료구조이자 FIFO(First In First Out)이다 .
- 한국말로는 선입선출, 먼저 넣은 것이 먼저 나온다는 뜻.
- 스택의 구현은 **리스트(혹은 연결리스트)**로 하면 된다.

### 큐 함수

```python
push : 큐에 값을 넣는 연산
pop : 큐에서 자료를 빼는 연산
front : 큐의 가장 앞에 있는 자료를 반환하는 연산
back : 큐의 가장 뒤에 있는 자료를 반환하는 연산
empty : 큐가 비어있는지의 여부를 반환하는 연산
```

### Deque로 큐 구현

```python
from collections import deque
dq = deque([1, 2, 3]) #값이 (1, 2, 3)인 양방향 큐 생성
dq.append(4) #dq의 오른쪽에 4 enqueue
x = dq.pop() #dq의 오른쪽 값을 dequeue해서 x에 대입
dq.appendleft(0) #dq의 왼쪽에 0을 enqueue
y = dq.popleft() #dq의 왼쪽 값을 dequeue해서 y에 대입

print(x, y) #4 0
```

### 큐 구현

```python
class Queue:
    def __init__(self):
        self.queue = []

    def isEmpty(self):
        if not self.queue:
            return True
        else:
            return False

    def enqueue(self, data):
        self.queue.append(data)

    def dequeue(self):
        if self.isEmpty():
            return "Queue is Empty"
        else:
            dequeued = self.queue[0]
            # 꺼낸 뒤 나머지 재정비
            self.queue = self.queue[1:]
            return dequeued

    # front가 무엇인지만 보여준다.
    def peek(self):
        if self.isEmpty():
            return "Queue is Empty"
        else:
            peeked = self.queue[0]
            return peeked
```