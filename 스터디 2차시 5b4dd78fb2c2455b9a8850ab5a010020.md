# 스터디 2차시

Date: 2022년 7월 15일

<aside>
💡 **주제 : 힙 & 우선순위 큐
발표자 : 김영진**

</aside>

### 출석

---

### 지난 과제

### 과제

[최대 힙](https://www.acmicpc.net/problem/11279), [최소 힙](https://www.acmicpc.net/problem/1927), [절댓값 힙](https://www.acmicpc.net/problem/11286),  [가운데를 말해요](https://www.acmicpc.net/problem/1655)

### 힙(Heap)

- 힙은 일종의 트리로 수의 집합에서 가장 작은 수(키)나 가장 큰 수만을 자주 꺼내올때 유용한 자료구조
- 힙의 목적은 삭제 연산에서 가장 큰 값을 효율적으로 찾아내기만 하면 되는 것이므로 전체를 정렬할 필요 없음 (일종의 반 정렬 상태)
- [삽입], [삭제]의 시간복잡도 : **O(logN)**

**{ 9, 8, 7, 6, 5, 4, 3, 2, 1}**

for 루프 → 시간복잡도 O(n)

- **완전 이진 트리**를 기초로 하는 자료구조

---

- **완전 이진 트리란?**
    - 마지막을 제외한 모든 노드에서 자식들이 꽉 채워진 이진트리

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled.png)

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%201.png)

---

- **최대힙(Max Heap)** : 부모노드의 값이 자식노드들의 값보다 항상 크다.
    
    *key(부모노드) ≥ key(자식노드)*
    
- **최소힙(Min Heap)** : 부모노드의 값이 자식노드의 값보다 항상 작다.
    
    *key(부모노드) ≥ key(자식노드)*
    
- 힙은 **중복값을 허용**(최댓값, 최솟값을 쉽게 뽑기 위한 자료구조임으로 중복 허용)

### **우선순위 큐(Priority Queue)**

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%202.png)

- **우선순위**의 개념을 큐에 도입한 자료구조
- 데이터들이 우선순위를 가지고 있어 우선순위가 높은 데이터가 먼저 출력됨
- 우선순위 큐를 구현하기 위한 **가장 효율적인** 구조는 **힙(Heap)**

- **우선순위 큐의 추상 자료형(ADT)**
    
    <aside>
    💡 객체: n개의 element 형의 우선순위를 가진 요소들의 모임
    
    연산:
    create() ::= 우선 순위큐를 생성한다.
    init(q) ::=  우선 순위큐 q를 초기화한다.
    is_empty(q) ::= 우선 순위큐 q가 비어있는지를 검사한다.
    is_full(q) ::= 우선 순위큐 q가 가득 찼는가를 검사한다.
    **insert(q, x)** ::= 우선 순위큐 q에 요소 x를 추가한다.
    **delete(q)** ::= 우선 순위큐로부터 가장 우선순위가 높은 요소를 삭제 후 반환한다.
    find(q) ::= 우선 순위가 가장 높은 요소를 반환한다.
    
    </aside>
    

- 우선순위 큐를 구현하는 방법
    - 배열을 이용한 우선순위 큐
    - 연결리스트를 이용한 우선순위 큐
    - 힙(heap)을 이용한 우선순위 큐

<aside>
💡 ***우선순위 큐를 배열이나 연결리스트로 구현하지 않는 이유*
(1) 배열**
- 우선순위가 높은 순서대로 배열의 앞부분부터 넣는다면, 우선순위가 높은 데이터를 반환하는 것은 어렵지 않음.(O(1))
- 하지만, 우선순위에 해당하는 데이터를 삽입하는 과정에서 다음 데이터들의 인덱스를 모두 한 칸씩 뒤로 밀어야하는 단점이 존재함.
- 최약: 삽입해야하는 위치를 찾기 위해 모든 인덱스 탐색(O(n))
**(2) 연결리스트**
- 배열과 마찬가지로 우선순위 데이터 반환은 쉬움.(O(1))
- 삽입의 과정에서 마찬가지로 위치를 찾아야하고, 최악: O(n)

</aside>

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%203.png)

- 배열로 구성된 **힙(heap)으로 우선순위 큐 구현하기**

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%204.png)

**자식노드를 구하고 싶을 때**

- 왼쪽 자식노드 index = (부모 노드 index) * 2
- 오른쪽 자식노드 index = (부모 노드 index) * 2 + 1

**부모노드를 구하고 싶을 때**

- 부모 노드 index = (자식노드 index) / 2

```c
#define MAX_ELEMENT 200
typedef struct {
	int key;
} element;

typedef struct {
    element heap[MAX_ELEMENT];
    int heap_size;
} HeapType;
```

- 힙에서의 **삽입(insert)**

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%205.png)

```c
// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입한다.
void insert_max_heap(HeapType* h, element item) {
	int i;
	i = ++(h->heap_size);

	//  트리를 거슬러 올라가면서 부모 노드와 비교하는 과정
	while ((i != 1) && (item.key > h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item;     // 새로운 노드를 삽입
}
```

- 힙에서의 **삭제(delete)**
    - 루트 노드를 삭제

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%205b4dd78fb2c2455b9a8850ab5a010020/Untitled%206.png)

```c
element delete_max_heap(HeapType *h) { 
    int parent, child; 
    element item, temp;

    item = h->heap[1]; // 최상위 노드
    temp = h->heap[(h->heap_size)--]; // 마지막 노드
    parent = 1;	
    child = 2;
    while( child <= h->heap_size ) {
	  if( ( child < h->heap_size ) && 
	      (h->heap[child].key) < h->heap[child+1].key)
	      	child++; // 오른쪽 자식이 왼쪽 자식보다 크면
	  if( temp.key >= h->heap[child].key ) // 마지막 노드와 key가 같으면
		break;
	  h->heap[parent] = h->heap[child];
	  parent = child; child *= 2; // 한단계 아래로 이동
    }
    h->heap[parent] = temp; // temp를 연결
    return item;
 }
```

### Priority_Queue

priority_queue<자료형, 구현체, 비교연산자>

비교연산자: less<자료형>, greater<자료형>

less는 내림차순, greater는 오름차순

```c
**pq.push()** //데이터 삽입
**pq.size()** //길이 return
**pq.top()** //가장 우선순위가 높은 원소
**pq.empty()** //큐가 비었는지 검사
```

```cpp
#include <iostream>
#include <string>
#include <queue>
using namespace std;

int main() {
	// priority_queue<int> q;	// 내림차순 
	// priority_queue<int, vector<int>, less<int> > q;	// 내림차순
	priority_queue<int, vector<int>, greater<int> > q;	// 오름차순

	if (q.empty()) cout << "우선순위 큐가 비었습니다.\n";

	q.push(4);
	q.push(4);
	q.push(2);
	q.push(1);
	q.push(3);

	cout << "맨 위 : " << q.top() << "\n";

	cout << "나가는 순서 : ";
	while (!q.empty()) {
		cout << q.top() << " ";
		q.pop();
	}
	cout << "\n";

	return 0;
}

//결과: 1 2 3 4 4
```

**+) 파이썬**

```python
from queue import PriorityQueue
que.put(4)
que.put(1)
que.put(7)
que.put(3)
print(que.get())  # 1
print(que.get())  # 3
print(que.get())  # 4
print(que.get())  # 7
```

---

+) **힙 정렬(Heap Sort)**

힙 정렬이란 최대 힙트리나 최소 힙트리를 이용한 정렬 알고리즘 중 하나이다.

**힙 정렬 알고리즘**

1. n개의 요소를 하나씩 힙에 삽입한다.
2. n번에 걸쳐 힙에서 요소를 하나씩 삭제하고 반환된 값을 순차적으로 정렬한다.