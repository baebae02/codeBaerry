# 스터디 3차시

Date: 2022년 7월 24일 오후 11:00

<aside>
💡 **주제 : 셋, 맵
발표자 : 이수빈**

</aside>

### 출석

- [x]  서현
- [x]  상윤
- [x]  영진

- [x]  수빈
- [x]  하람
- [x]  채희

---

### 지난 과제

- [x]  서현
- [x]  상윤
- [x]  영진

- [x]  수빈
- [x]  하람
- [x]  채희

### 과제

[문자열 집합](https://www.acmicpc.net/problem/14425),  [듣보잡](https://www.acmicpc.net/problem/1764), [서로 다른 부분 문자열의 개수](https://www.acmicpc.net/problem/11478)

---

### 연관 컨테이너 ****(Associative Container)****

연관 컨테이너는 Key - Value 구조를 가진 컨테이너를 의미한다. set은 key 값만 가지고 만든 집합이고, map은 key-value 페어를 이용한다.

### 셋

- 다양한 자료형의 데이터 저장 (key)
- key 값을 **중복 없이** 저장
- key 값을 **정렬된 상태**로 저장 (default : 오름차순)
- 검색, 삽입, 삭제에서의 시간복잡도는 O(logn)
- 랜덤한 인덱스의 데이터에 접근불가

**멤버 함수**

```cpp
// C++
// 헤더 선언 필요
#include <set>

// int 자료형을 저장하는 셋 선언
set<int> s;

s.begin() : 맨 첫번째 원소를 가리키는 반복자를 리턴 // 반복자? -> 포인터와 비슷한 개념
s.end() : 맨 마지막 원소+1을 가리키는 반복자를 리턴
s.clear() : 모든 원소를 제거
s.insert(k) :원소 k를 자동으로 정렬된 위치에 삽입.
s.insert(iter, k) : iter가 가리키는 위치 부터 k를 삽입할 위치를 탐색하여 삽입
s.find(k): 원소 k를 가리키는 반복자를 반환. 원소 k가 없다면 s.end() 와 같이 맨끝을 가리키는 반복자를 반환
s.size() : 사이즈(원소의 갯수)를 반환
s.erase(k/iter) :k를 제거, iter가 가리키는 원소를 제거
```

```python
# python
myset = set()
myset = set([1, 1, 1, 2, 2, 2, 3, 3, 3])
myset.add(1) # 요소 추가
myset.remove(2) # 요소 제거
```

> **O(logn)의 시간 복잡도가 가능한 이유!**
> 

만일 벡터였다면 원소가 존재하는지 아닌지 확인하기 위해 벡터의 처음부터 끝까지 비교해야 한다. 최악의 경우엔 모든 원소를 탐색해야 한다.(즉 벡터에서 탐색은 O(N)).

하지만 셋의 경우 O(log N)으로 원소가 존재하는지 확인할 수 있다. 이것이 가능한 이유는 셋 내부적으로 **원소들이 정렬된 상태**를 유지하기 때문이다.

셋이 이러한 방식으로 작업을 수행할 수 있는 이유는 내부적으로 **트리 구조**로 구성되어 있기 때문이다.

**이진 탐색 트리 (BST, Binary Search Tree)**

- 왼쪽에 오는 모든 노드들은 나보다 작다.
- 오른쪽에 있는 모든 노드들은 나보다 크다.
- 정확히는 BST의 발전 형태인 **RBT(Red Black Tree)**를 사용한다고 함.
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%203%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%20fe1c93ae614d462c85172468110103f3/Untitled.png)
    

***그렇다면 위 구조에서 25 를 찾으려면 어떻게 할까요?***

1. 일단 최상위 노드(루트 노드)와 비교 : 25 > 20 → 오른쪽 노드로 간다
2. 30 과 비교 : 25 < 30 → 왼쪽 노드로 간 30 과 비교 : 25 < 30 → 왼쪽 노드로 간다
3. 25 와 비교 : 25 == 25 → 당첨 25 와 비교 : 25 == 25 → 당첨!

전체 원소 개수는 8개 이지만, 단 3번의 비교로 원소를 정확히 찾을 수 있습니다.

***그렇다면 12 를 찾으려면 어떻게 할까요? 참고로 12는 위 셋에 들어있지 않은 원소***

1. 루트 노드와 비교 : 12 < 20 → 왼쪽 노드로 간다
2. 15 와 비교 : 12 < 15 → 왼쪽 노드로 간 15 와 비교 : 12 < 15 → 왼쪽 노드로 간다
3. 10 과 비교 : 12 > 10 → 오른쪽 노드로 가야하지만 오른쪽에 아무것도 없다. 따라서 이 원소는 존재하지 않는다 10 과 비교 : 12 > 10 → 오른쪽 노드로 가야하지만 오른쪽에 아무것도 없다. 따라서 이 원소는 존재하지 않는다.

만일 벡터 였다면 원소들을 처음 부터 끝까지 확인해봐야 했지만 셋의 경우 단 **3번의 비교**만으로 12가 셋에 존재하는지 아닌지 여부를 판단할 수 있다.

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%203%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%20fe1c93ae614d462c85172468110103f3/Untitled%201.png)

### 맵

- 다양한 자료형의 데이터를 **key-value** 쌍으로 저장
- key 값을 **중복 없이** 저장 (value 값은 중복 가능)
- key 값을 **정렬된 상태**로 저장
- 검색, 삽입, 삭제에서의 시간복잡도는 **O(log n)**
- **랜덤한 인덱스**의 데이터에 **접근불가**

**멤버 함수 (셋과 거의 동일)**

```cpp
// C++
#include <map> // 헤더 선언

map<int, string> m; // int, string 자료형을 저장하는 맵 선언

insert(1, "test1"); // 원소 추가(insert)

// 원소 추가(인덱스)
// 해당 키 값이 존재하지 않으면 원소가 추가되고, 존재하면 값이 수정된다.
m[2] = "test2";

// 원소 찾기
// 해당 key가 존재하면 iterator 반환. 없으면 m.end() 반환.
m.find(key);

auto mf = m.find(3);
cout << mf->first << " : " << mf->second << endl;

m.erase(key); // key에 해당하는 원소 제거
m.clear(); // 모든 원소 제거
m.size(); // 저장된 원소 개수 출력
```

```python
# python
student = {'name': 'John', 'age': 25, 'courses': ['Math', 'CompSci']}

# 존재하지 않는 키를 호출 -> KerError 발생
> print(student['phone'])
KeyError: 'phone'

# 예방하기 위해 get 메소드 사용
> print(student.get('phone'))
None
> print(student.get('phone', 'Not Found'))
Not Found

# 딕셔너리 데이터 업데이트
> student.update({'name': 'Kane', 'age': 44})
> print(student)
{'name': 'Kane', 'age': 44, 'courses': ['Math', 'CompSci']}

# 데이터 삭제하기 (del student['age']도 가능)
> age = student.pop('age')
> print(student)
{'name': 'John', 'courses': ['Math', 'CompSci']}
> print(age)
25

# 키, 값 리스트로 보기
> print(len(student))
> print(student.keys())
> print(student.values())
> print(student.items())
3
dict_keys(['name', 'age', 'courses'])
dict_values(['John', 25, ['Math', 'CompSci']])
dict_items([('name', 'John'), ('age', 25), ('courses', ['Math', 'CompSci'])])

# For-loop : 그냥 돌리면 키만 출력됨
> for key in student:
>    print(key)
name
age
courses

# 딕셔너리는 items으로 접근해서 루프를 돌려야 함
> for key, value in student.items():
>    print(key, value)
name John
age 25
courses ['Math', 'CompSci']
```

### 추가

**multiset, multimap**

셋과 맵은 중복 key를 허용하지 않지만, 멀티 셋과 멀티 맵은 **중복 key를 허용한다.**

```cpp
#include<set>
#include<map>

// 사용법은 일반 셋, 맵과 동일하다.
multiset<int> ms;
multimap<int, int> mm;
```

**unordered_set, unordered_map**

- 원소들이 순서대로 정렬되어 들어가지 않는다.

- 삽입, 삭제, 조회가 평균 O(1)를 보장한다.(최악의 경우는 O(n))

- 해시 함수를 이용하여 저장 공간을 결정한다.

- 너무 빈번하게 자료를 삽입, 삭제하지 않고 많은 자료 저장과 빠른 검색 속도를 사용할 때 사용한다.

```cpp
#include<unordered_set>
#include<unordered_map>

// 사용 방법은 set, map과 동일하다
unordered_set<int> us;
unordered_map<int, int> um;
```
