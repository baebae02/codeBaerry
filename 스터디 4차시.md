# 스터디 4차시

Date: 2022년 7월 27일

<aside>
📕 주제: 완전 탐색
발표자: 김하람

</aside>

## 과제

 [블랙잭](https://www.acmicpc.net/problem/2798), [분해합](https://www.acmicpc.net/problem/2231), [덩치](https://www.acmicpc.net/problem/7568), [체스판 다시 칠하기](https://www.acmicpc.net/problem/1018), [영화감독 숌](https://www.acmicpc.net/problem/1436)

### 출석

- [x]  서현
- [x]  수빈
- [x]  상윤

- [x]  영진
- [x]  하람
- [x]  채희

---

### 지난 과제

- [x]  서현
- [x]  상윤
- [x]  하람

- [x]  영진
- [x]  수빈
- [x]  채희

---

 

## 완전 탐색이란?

모든 경우의 수를 시도하는 방법!! 

-상대적으로 구현이 간단하고, 해가 존재하면 항상 찾을 수 있음

-경우의 수에 따라 실행 시간이 비례해서 커지기 때문에, 입력 값의 범위가 작은 경우에 유용함

## 완전 탐색 알고리즘

1. **Brute Force 기법**
단순히 반복문과 조건문을 통해 가능한 모든 방법을 찾는 경우를 의미한다. 
(ex) 자물쇠 암호를 하나씩 시도해보면서 열기

2. **순열(Permutation)**
서로 다른 n개를 일렬로 나열하는 방법(경우의 수)를 말한다. 
(ex) 수열 [1,2,3]과 수열 [3,2,1]은 다르다. 즉, 순서가 중요함!
순열의 경우의 수는 N!이고, 시간복잡도가 O(N!)으로 굉장히 큰 편에 속한다. 
- c++, Python은 순열 관련 라이브러리가 존재한다 (자바는 없음)
→ Permutations
3. **재귀(Recursive)**
재귀는 말 그대로 자기 자신을 호출한다는 의미이다. 
(ex) 피보나치 수열
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    int fibonacci(int x) {
    	if (x == 0)	return 0;
    	else if (x == 1)	return 1;
    	else {
    		return fibonacci(x - 2) + fibonacci(x - 1);
    	}
    }
    
    int main() {
    	int n;
    	cin >> n;
    
    	cout << fibonacci(n);
    	
    }
    ```
    
    시간복잡도는 O(N)이다.
    → 이는 5차시에서 자세히 다룰 것!
    
4. **비트마스크(Bitmask)**
비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.
→ 나올 수 있는 모든 경우의 수가 각각의 **원소가 포함되거나, 포함되지 않는 두 가지 선택으로 구성되는 경우** 유용하게 사용할 수 있다.
(ex) '원소가 n개인 집합의 모든 부분 집합'을 구한다면, 각 원소가 포함되는지 포함되지 않는지를 0, 1로 구분하여 배열에 저장해둘 수 있음

비트 연산에는 다음과 같은 것들이 있다.

[비트 연산]
    
    And 연산(&) : 둘 다 1이면 1
    OR 연산(|) : 둘 중 1개만 1이면 1
    NOT 연산(~) : 1이면 0, 0이면 1
    XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0
    Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B 비트만큼 미는 것
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%204%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%209c947eae24414cd9aaf459f382f5031b/Untitled.png)
    
    [비트 연산으로 집합을 나타내는 방법]
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%204%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%209c947eae24414cd9aaf459f382f5031b/Untitled%201.png)
    
    저 비트를 10진수로 보면 570이 되기 때문에, 이 정수로 사용하게 되면 전체 저장 공간이 절약도 되고 정수이기 때문에 index로 활용이 가능하다는 장점이 있다. 
    
    [비트 연산 활용]
    -집합 포함 여부 검사 : AND(&)연산
    -숫자 추가 : OR(|) 연산
    -특정 숫자 제거 : NOT(~)연산과 AND(&)연산 같이 사용
    
    → 이러한 방법들을 응용하여, 비트마스크로 완전 탐색 문제를 해결할 수 있다. 비트마스크는 보통 처리할 전체 데이터가 정해져 있고 그 안에서 특정 개수를 가지고 연산을 수행할 때 사용한다. 
    
    비트 연산의 시간복잡도는 내부적으로 상수 시간 정도로 처리가 되어 O(1)이다. 
    
5. **BFS, DFS**
그래프 자료 구조에서 모든 정점을 탐색하기 위한 방법
- BFS(Breadth-First Search) 
: 너비 우선 탐색, 현재 정점과 인접한 정점을 우선으로 탐색 / 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법 사용 

- DFS(Depth-First Search) 
: 깊이 우선 탐색, 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하여 끝까지 탐색하는 방식 / 모든 노드를 방문하고자 할 때 사용 

BFS와 DFS를 사용한 경우, 두 알고리즘 모두 인접행렬을 사용하여 만든 그래프의 경우에는 **O(n^2)**의 시간복잡도를 가지고 인접리스트를 사용하여 만든 그래프의 경우에는 **O(n+e)**의 시간복잡도를 가진다.

→ 이는 7차시에서 자세하게 다룰 것이니 이정도로만 알아두자!