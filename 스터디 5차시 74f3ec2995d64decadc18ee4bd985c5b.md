# 스터디 5차시

Date: 2022년 7월 31일 오전 10:00

<aside>
💡 **주제: 재귀**

**발표자: 박상윤**

</aside>

### 출석

- [x]  서현
- [x]  상윤
- [x]  영진
- [x]  수빈
- [ ]  하람
- [x]  채희
    
    ---
    

### 지난 과제

- [x]  서현
- [x]  상윤
- [x]  영진
- [x]  수빈
- [ ]  하람
- [x]  채희

---

### 과제

[팩토리얼](https://www.acmicpc.net/problem/10872), [피보나치 수 5](https://www.acmicpc.net/problem/10870), [재귀함수가 뭔가요?](https://www.acmicpc.net/problem/17478), [별 찍기 - 10](https://www.acmicpc.net/problem/2447), [하노이 탑 이동 순서](https://www.acmicpc.net/problem/11729)

---

### 재귀 알고리즘(Recursive)

- 분할 정복법의 한 종류.
- 분할 정복법이란 큰 문제를 작은 구조의 문제로 쪼개가며 문제를 해결하는 방식.

~~(피라미드 꼭대기에서 아래로 내려가는 느낌?)~~

- 임의의 함수가 자기 자신을 호출하는 재귀 호출을 이용하는 알고리즘.
- 스택처럼 호출한 함수를 쌓았다가 종료 조건을 만나면 위에서부터 하나씩 처리하는 방식.

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%205%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%2074f3ec2995d64decadc18ee4bd985c5b/Untitled.png)

- 종료 조건이 없으면 함수가 무한히 호출되기 때문에 종료 조건이 반드시 필요.
- 예시

```python
#n까지 합 구하기
def sum(n):
    if n==1:            #종료 조건
        return 1
    return n+sum(n-1)
```

---

### 반복문과 재귀 알고리즘 비교

- 모든 재귀 알고리즘은 반복문으로 표현 가능.
    - 피보나치 수열

```c
//반복문
int a = 1, b = 1, c, n;
scanf("%d", &n);
for (i = 1; i <= n; ++i)
    {
        printf("%d ", a);
        c = a + b;
        a = b;
        b = c;
    }
```

```c
//재귀 알고리즘
int fibo(int n)
{
	if (n == 0)
		return 0;
	else if (n == 1)
		return 1;
	return fibo(n - 1) + fibo(n - 2);
}
```

- 재귀 알고리즘은 반복문과 달리, 각 호출마다 스택 메모리를 사용하고, 속도가 느림.
    
    → 무한 재귀에 들어가게 되면 오버플로우 발생.
    
- 위 예시의 경우는 그렇지 않지만, 대부분의 재귀 알고리즘이 반복문보다 코드 길이와 변수가 적어 가독성이 높음.

---

### 피보나치 수열

```python
#Python
def fibo(n):
    if n<=2:
        return 1
    return fibo(n-1)+fibo(n-2)
```

- 시간 복잡도: O(2^n)

(F(2)와 같이 중복되는 값이 시간 복잡도를 키우는 요인이 됨.)

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%205%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%2074f3ec2995d64decadc18ee4bd985c5b/Untitled%201.png)

---

### 퀵 정렬(Quick Sort)

- 리스트 안의 한 원소를 피벗(pivot)으로 선택하고, 이 숫자를 기준으로 리스트를 분할하여 피벗보다 작거나 같은 원소를 앞쪽에, 큰 원소를 뒷쪽에 배치.
- 리스트를 더 이상 분할할 수 없을 때까지 반복.
- 분할→정복(나열)→결합

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%205%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%2074f3ec2995d64decadc18ee4bd985c5b/Untitled%202.png)

```python
#Python
def quick(a):
    if len(a)<2:
        return a
    else:
        key=a[0]
        left=[data for data in a[1:] if data<=key] #key보다 작거나 같은 data를 left에 저장
        right=[data for data in a[1:] if data>key] #key보다 큰 data를 right에 저장
        return quick(left)+[key]+quick(right) #list형으로 반환 & 결합

print(quick([20,50,30,10,60,40])) #[10,20,30,40,50,60]

```

- 시간 복잡도
    - 최선: O(nlogn)
    - 최악: O(n^2) → 이미 정렬이 돼있거나 역순으로 정렬된 배열의 경우
    - 평균: O(nlogn)
    - [https://jeonyeohun.tistory.com/102](https://jeonyeohun.tistory.com/102)

---

### 시간 복잡도

- [https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=wns7756&logNo=221568348621](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=wns7756&logNo=221568348621)

---